파이썬이 최근에 주목받는 이유 중 하나가 바로 데이터 분석을 위한 다양한 패키지를 제공한다는 점입니다.
데이터 분석을 위해 정교하게 만들어진 통계 패키지를 사용하면 사업계획서를 위한 재무 자료 분석부터 경제적 자유를 이우기 위한 주식 및 부동산 자료 분석까지 직접해 볼 수 있습니다. 
이 장에서는 대표적인 파이썬 패키지인 넘파이, 판다스 , 맷플롯립을 활용해 데이터 분석을 해 보겠습니다.

05-1 데이터 분석 패키지 준비하기
05-2 넘파이로 배열 다루기
05-3 넘파이로 사업성 분석하기
05-4 판다스로 데이터프레임 만들기
05-5 판다스로 통계 데이터 다루기
05-6 실전 통계 분석 맛보기
05-7 맷플롯립으로 그래프 그리기

05-1 데이터 분석 패키지 준비하기

파이썬의 다양한 패키지를 사용하면 다른 데이터 분석 프로그램 못지않게 분석이 가능합니다. 하지만 파이썬 자체가 데이터 분석 프로그램은 아닙니다. 그래서 목적에 맞는 패키지를 따로 설치해야 합니다. 다음은 대표적인 파이썬 데이터 분석 패키지입니다.
┌───────────────────┬───────────────────────────────┬───────────────────────┐
│ 패키지				│ 기능     						│ 주요함수					│
├───────────────────┼───────────────────────────────┼───────────────────────┤
│ 넘파이(numpy)		│ 배열 계산 기능, 반올림, 버리기 기능	│ floor, ceil, power	│
├───────────────────┼───────────────────────────────┼───────────────────────┤
│ 판다스(pandas)		│ 데이터프레임으로 데이터 입력, 가공		│ describe, groupby		│
├───────────────────┼───────────────────────────────┼───────────────────────┤
│ 맷플롯립(matplotlib)	│ 그래프 그리그						│ plot, hist, bar		│
└───────────────────┴───────────────────────────────┴───────────────────────┘

이들 패키지 말고도 math(수학), scipy(통계 분석), statsmodels(통계 모델 작성 및 분석) 등 데이터 분석을 위한 파잌썬 패키지는 많이 있습니다. 그리고 이런 패키지의 사용 방법은 하나의 책으로 담기 어려울 정도로 다양합니다. 따라서 이 책에서는 여러분이 실제로 맞닥뜨릴 수 있는 상황을 중심으로 그 사용번을 간단히 알아보겠습니다.

데이터 분석 패키지 설치하기

아나콘다를 통해서 파이썬을 설치했다면 이미 넘파이, 판다스 , 맷플롯립이 기본적으로 설치되어 있습니다. 처음에 아나콘다를 설치하라고 추천한 이유가 여기에 있습니다. 기본적인 패키지가 모두 설치되어 있어서 이 패키지들을 굳이 따로 설치하지 않아도 되기 때문이죠.

패키지가 설치되어 있지 않다면 다으모가 같이 입력해서 설치하세요. 명령 프롬프트에서 파이썬 실행 위치로 이동한 다음 pip 명열을 입력하면 패키지가 설치됩니다.

C:\User\user\> pip install numpy
# 이처럼 필요한 패키지 이름을 직접 pip 로 설치하는 방법도 있습니다.

마찬가지로 판다스, 맷플롯립과 같은 다른 패키지를 설치하고 싶다면 다으모가 같이 입력합니다.
C:\User\user\> pip install pandas
C:\User\user\> pip install matplotlib


05-2 넘파이로 배열 다루기 == 05-1.py 참고

넘파이는 배열(array)을 다루는 도구이며 숫자로 된 큰 배열 데이터를 다룰 때 진가를 발휘합니다. 예를 들어 엄청나게 많은 데이터 중에서 700이 넘는 숫자만 찾아서 참(True)으로 반환하거나, 특정한 행이나 열에 있는 정보만 반올림하거나 버림하기도 쉽습니다. 또한 복잡한 배열 연산도 가능합니다.

이 절의 목적은 다른 절과 마찬가지로 넘파이의 기능을 정복하는 데 있지 않습니다. 넘파이의 기능을 설명하는 포스팅이나 책은 무궁무진합니다. 당장 구글에 'python numpy'라고만 검색해도 수많은 컴퓨터 전공자, 프로그래머의 엄청난 블로그들이 확인됩니다. 따라서 이 책의 역활은 넘파이의 기능 모두를 설명하는 것이 아니라, 주변에서 흔히 접하는 어떤 문제를 넘파이로 해결할 수 있음을 보여주는 데 있습니다.

자, 그럼 시작해 보겠습니다.

넘파이로 배열 정의하기

뱌열을 표현하기 위해 먼저 넘파이를 임포트 합니다.
┌───────────────────────────────────────────────────────────────────────────┐
│   >>> import numpy as np  # 넘파이를 불러올 때 보통 np로 줄여서 표현합니다.			│
└───────────────────────────────────────────────────────────────────────────┘

넘파이를 불러올 때 np로 줄여서 표현합니다. 이렇게 표현하지 않아도 상관없지만, 정말 많은 책과 포스팅에서 넘파이를 np라고 줄여서 사용하기 때문에 이렇게 사용하는 것을 추천합니다.

넘파이는 기본적으로 '배열'을 표현하기 위한 패키지입니다. 이를 사용해 2차원 배열을 만들어 보겠습니다.
┌───────────────────────────────────────────────────────────────────────────┐
│   >>> a = np.array([[2,3],[5,2]])											│
│   # np.array는 배열을 정의하는 명령입니다. 첫 번째 행부터 리스트로 입력합니다.				│
│																			│
│   >>> a																	│
│   # 배열이 정상적으로 입력되었습니다.												│
└───────────────────────────────────────────────────────────────────────────┘

넘파이의 배열은 지금까지 다뤘던 CSV형 리스트와 아주 비슷한 형태입니다. 앞에서 만든 2차원 배열을 그림으로 표현하면 다음과 같습니다.

        2열
    ┌───┬───┐
    │ 2 │ 3 │
2행	├───┼───┤
    │ 5 │ 2 │
    └───┴───┘

배열 스라이싱 하기

넘파이의 스라이싱 기능은 리스트의 스라이싱 기느오가 유사하지만 숫자를 다루는 데 더 특화되어 있으며 수를 다룰 때 강력합니다. 2차원 배열을 새로 만들겠습니다.
┌───────────────────────────────────────────────────────────────────────────┐
│   >>> d = np.array([[1, 2, 3, 4, 5],[2, 4, 5, 6, 7],[5, 7, 8, 9, 9]])		│
│   # 3 x 5 배열을 만들어 d에 저장합니다.											│
│																			│
│   >>> d																	│
│   array( [[1, 2, 3, 4, 5],												│
│           [2, 4, 5, 6, 7],												│
│           [5, 7, 8, 9, 9]])												│
└───────────────────────────────────────────────────────────────────────────┘

슬라이싱 기능을 사용하려면 각 원소의 인덱스를 알아야 합니다. 이 다차원 배열의 인덱스는 다음과 같습니다. 앞서 다뤘던 CSV형 자료의 인덱스가 넘파이에서 동일하게 매겨집니다.
┌───────────────────────────────────────────────────┐
│       d[0][0]          d[0][1]     d[0][-1]		│
│            ↖       ↗           ↗					│
│   array( [[【1】, 【2】, 3, 4, 【5】],			│
│       ↙  [【2】, 4, 5,   【6, 7】],    d[1:,3:]	│
│   d[1][0] [5, 7, 8,       【9, 9】]])  ↗			│
└───────────────────────────────────────────────────┘

즉, 넘파이로 배열을 표현할 떄 첫 번째 인덱스는 행, 두 번째 인덱스는 열을 가리킵니다. 예를 들어 앞 그림에서 볼때 d[2][4]라고 한다면, 3번째 행, 5번째 열을 가리키는 셈입니다.
┌───────────────────────────────────────────────────────────────────────────────────┐
│   >>> d[1][2]																		│
│   5             # d[1][2]를 행렬식으로 표현하면 [d오른쪽아래에 작은크기로 23] 에 해당하는 수입니다.	│
│   >>> d[1, 2]																		│
│   5             # 이처럼 표현할 수도 있습니다.											│
│   >>> d[1:, 3:]																	│
│   array([[6, 7],																	│
│         [9, 9]]) # 1행 다음, 3열 다음 수만 슬라이싱 했습니다.								│
└───────────────────────────────────────────────────────────────────────────────────┘

배열의 크기 알아내기: shape
배열의 크기는 배열이 몇 개의 행과 열을 가졌는지를 의마합니다. 앞에서 보았던 배열 d는 3X5 배열이라고 표현합니다. 파이썬에서는 3X5를(3, 5)라고 표현하고요. d.shape라고 입력하면 배열 d의 크기를 알 수 있습니다.
┌───────────────────────────────────────────────────────────────────────────────────────────────┐
│   >>> d = np.array([2, 3, 4, 5, 6])               # 1x5 배열을 만듭니다.							│
│   >>> d																						│
│   array([2, 3, 4, 5, 6])																		│
│   >>> d.shape																					│
│   (5,)                                        	# d는 한 개 리스트에 각 다섯 개의 원소를 가지고 있습니다.	│
│   >>> e = np.array([1, 2, 3, 4], [3, 4, 5, 6])    # 2x4 배열을 만듭니다.							│
│   >>> e																						│
│   array([1, 2, 3, 4],																			│
│           [3, 4, 5, 6])																		│
│   >>> e.shape																					│
│   (2, 4)                                      	# e는 두 개 리스트에 각 네 개의 원소를 가지고 있습니다.	│
└───────────────────────────────────────────────────────────────────────────────────────────────┘

배열의 원소 유형 확인하기: dtype

배열에서 원소의 유형(type)이 무엇인지 아는 것은 매우 중요합니다. 예를 들어 배열이 숫자로 되어 있으면 연산을 할 수 있고, 배열이 문자형으로 되어 있다면 정규식을 사용할 수 있습니다. 예를 들어 d.dtype을 입력하면 배열 d의 자료형을 알 수 있습니다.
┌───────────────────────────────────────────┐
│   >>> d.dtype     # 배열 d의 자료형을 확인합니다.	│
│   dtype('int32')  # 정수로 이뤄졌다는 의미입니다.	│
└───────────────────────────────────────────┘

d.dtype의 결괏값으로 dtype('int32')가 출력되었습니다. 이는 배열 d가 정수 원소로 이루어져 있다는 뜻입니다. 배열의 원소 유형에 따른 표기는 다음 표와 같습니다.
% 여기서 16, 32, 64는 용량을 의미합니다. 숫자가 작을수록 작은 숫자만 담을 수 있고, 숫자가 클수록 큰 수를 담을 수 있습니다.

표 5-2 | 배열의 원소 유형에 따른 표기법
┌───────────────────────┬───────────────────┐
│   원소 유형				│   표기법			│
├───────────────────────┼───────────────────┤
│   부호가 있는 정수			│   int(32,64)		│
├───────────────────────┼───────────────────┤
│   부호가 없는 정수			│   int(32,64)		│
├───────────────────────┼───────────────────┤
│   실수					│    int(32,64)		│
├───────────────────────┼───────────────────┤
│   복소수				│	float(32,64)	│
├───────────────────────┼───────────────────┤
│   불(참 거짓을 가지는 자료)	│	bool			│
├───────────────────────┼───────────────────┤
│   문자열				│   string			│
├───────────────────────┼───────────────────┤
│   파이썬 오브젝트			│	object  		│
├───────────────────────┼───────────────────┤
│   유니코드				│   unicode 		│
└───────────────────────┴───────────────────┘

배열 유형 바꾸기: astype()
04장에서는 usercsv 모듈에 저장한 switch()함수를 사용해 바꿀 수 있는 모든 숫자 원소를 숫자형으로 바꿨습니다. 넘파이를 사용하면 유형을 더 쉽게 변경할 수 있습니다. 넘파이에 들어 있는 astype()를 사용하면 됩니다. astype()는 배열의 원소가 가지는 유형을 바꾸는 함수입니다.
┌───────────────────────────────────────────────────────────────────┐
│	>>> data = np.arange(1, 5)	# 1부터 4까지로 이루어진 배열을 생성합니다.	│
│	>>> data.dtype													│
│	dtype('int32')				# 유형을 확인하니 정수입니다.				│
│	>>> data.astype('float64')										│
│	array([1., 2., 3., 4.])		# data 배열의 원소를 모두 실수로 바꿨습니다.	│
│	>>> data.astype('int32')										│
│	array([1, 2, 3, 4])			# 다시 정수로 바꿀 수도 있습니다.			│
└───────────────────────────────────────────────────────────────────┘

넘파이 함수 알아보기
앞으로 자주 쓸 넘파이의 여러 함수를 알아보겠습니다.

0으로 이뤄진 배열 만들기: np.zeros()
np.zeros()함수는 0으로 이뤄진 배열을 만듭니다.
┌───────────────────────────────────────────────────────────────────────┐
│	>>> np.zeros((2, 10))	# 행이 2이고 열일 10이며 각 원소가 0인 배열을 만듭니다.	│
│	array([[0., 0., 0., 0., 0., 0., 0., 0., 0., 0., ],					│
│			[0., 0., 0., 0., 0., 0., 0., 0., 0., 0., ]])				│
└───────────────────────────────────────────────────────────────────────┘

1로 이워진 배열 만들기: np.ones()
np.ones() 함수는 1로 이뤄진 배열을 만듭니다.
┌───────────────────────────────────────────────────────────────────────┐
│	>>> np.ones((2, 10))	# 행이 2이고 열일 10이며 각 원소가 1인 배열을 만듭니다.	│
│	array([[1., 1., 1., 1., 1., 1., 1., 1., 1., 1., ],					│
│			[1., 1., 1., 1., 1., 1., 1., 1., 1., 1., ]])				│
└───────────────────────────────────────────────────────────────────────┘

연속형 정수 생성하기: np.arange()
np.arange()함수느 특정 범위에 있는 원소를 자동으로 만듭니다.
┌───────────────────────────────────────────────────────────────────────────┐
│	>>> np.arange((2, 10))		# 2 이상 10 미만의 원소로 이뤄진 1차원 배열을 만듭니다.	│
│	array([2, 3, 4, 5, 6, 7, 8, 9])											│
└───────────────────────────────────────────────────────────────────────────┘

행과 열을 바꾸기: np.transpose()
배열을 다루다 보면 행과 열을 바꿔야 하는 상황이 종종 발생하지요. 이때는 transpose() 함수를 쓰면 됩니다.
┌───────────────────────────────────────────────────────────────────────────┐
│	>>> a = np.ones((2, 3))			# 원소가 전부 1인 2x3 배열을 만듭니다.			│
│	>>> a																	│
│	array([	[1., 1., 1.],													│
│			[1., 1., 1.]	])												│
│	>>> b = np.transpose(a)			# a에 저장된 배열의 행과 열을 바꿔 b에 저장합니다.	│
│	>>> b																	│
│	array([	[1., 1.],														│
│			[1., 1.],														│
│			[1., 1.]])														│
└───────────────────────────────────────────────────────────────────────────┘

배열의 사칙 연산
배열끼리도 사칙 연산을 할 수 있습니다. 그런데 곱셈과 나눗셈의 경우에는 행력의 연산 방식과 다르므로 꼭 알아두어야 합니다. 사칙 연산에 사용할 (3,3) 크기를 가진 서로 다른 배열 arr1, arr2를 정의하겠습니다.
┌───────────────────────────────────────────────────────┐
│	>>> arr1 = np.array([[2, 3, 4], [6, 7, 8]])			│
│	>>> arr2 = np.array([[12, 23, 14], [36, 47, 58]])	│
└───────────────────────────────────────────────────────┘

배열의 덧셈
arr1과 arr2를 더하면 같은 자리의 원소끼리 더합니다. 예를 들어 새로운 배열의 [0][0] 자리에는 arr1[0][0]인 2와 arr2[0][0]인 12를 더한 값인 14가 저장됩니다.
┌───────────────────────────┐
│	>>> arr1 + arr2			│
│	array([	[14, 26, 18],	│
│			[42, 54, 66])	│
└───────────────────────────┘

배열의 곱셈
배열끼리 곱하면 행렬처럼 곱셈이 진행되는 것이 아니라 같은 자리의 원소끼리 곱합니다.
┌───────────────────────────────────────────────────┐
│	>>> arr1 * arr2									│
│	array([	[24, 69, 56],							│
│			[216, 329, 464])	# 행렬의 곱셈과 다릅니다.	│
└───────────────────────────────────────────────────┘

배열의 나눗셈
배열을 배열로 나누면 같은 자리의 원소끼리 나눕니다.
┌───────────────────────────────────────────────────────────────────────────────────┐
│	>>> arr1 / arr2																	│
│	array([	[0.16666667 0.13043478 0.28571429],										│
│			[0.16666667 0.14893617 0.13793103])	# array[0][0] =2/16 = 0.16666667	│
└───────────────────────────────────────────────────────────────────────────────────┘

크기가 서로 다른 배열끼리 더하기
(3, )크기의 배열 arr3을 다음과 같이 정의합니다.
┌───────────────────────────────────────────┐
│	>>> arr3 = np.array([100, 200, 300])	│
└───────────────────────────────────────────┘

아까 만들었던 arr1과 arr3를 더할 수 있을까요? 넘파이에서는 가능합니다. 이처럼 서로 다른 크기의 배열을 연산하는 기능을 브로드캐스팅(broadcasting) 기능이라고 합니다. 인공지능에서 많이 쓰이는 유용한 기능이라고 하니 알아둘 필요가 있겠네요.
┌───────────────────────────────────────────────┐
│	>>> arr1.shape								│
│	(2,3)										│
│	>>> arr3.shape								│
│	(3,)			# arr1과 arr3는 크기가 다릅니다.	│
│	>>> arr1 + arr3								│
│	array[	[102, 203, 304],					│
│			[106, 207, 308]]					│
└───────────────────────────────────────────────┘

계산된 결과를 보면 arr3의 값이 arr1[0]과 arr1[1]에 각각 더해졌음을 확인할 수 있습니다.

브로드캐스팅이 되지 않는 경우도 있습니다. 예를 들어 보겠습니다. (10,) 크기의 배열 arr4를 만들어 (2,3) 크기의 배열 arr1과 더하면 어떻게 될까요?

┌───────────────────────────────────────────────┐
│	>>> arr4 = np.array([1,2,3,4,5,6,7,8,9,10])	│
│	>>> arr4.shape								│
│	(10,)                                       │
│	>>> arr1.shape                              │
│	(2,3)                                       │
│	>>> arr1 + arr4                             │
└───────────────────────────────────────────────┘
결과
┌───────────────────────────────────────────────────────────────────────────┐
│	예외가 발생했습니다. ValueError												│
│	operands could not be broadcast together with shapes (2,3) (10,) 		│
│	  File "C:\000_002_Python\01_Start\5장\05-1.py", line 111, in <module>	│
│	    arr1 + arr4															│
│	                                                                        │
│	# 행과 열의 크기가 모두 다 다른 배열은 더할 수 없네요.								│
└───────────────────────────────────────────────────────────────────────────┘

즉, 특정 조건을 만족해야 두 배열을 더할 수 있습니다. (2,1) 크기의 arr5 벼열으 만들어서 arr1배열에 더해 보겠습니다.
┌───────────────────────────────────────────────────────────────────────┐
│	>>> arr5 = np.array([[9], [3]])										│
│	>>> arr5.shape														│
│	(2,1)                                       						│
│	>>> arr1															│
│	array([	[2, 3, 4], 													│
│			[6, 7, 8]])													│
│	>>> arr1 + arr5                             						│
│	array([	[11, 12, 13], 												│
│			[9, 10, 11]])	# arr1[0,:](1행)에 arr5[0][0]인 9를 각각 더합니다.	│
│	# (2,3)크기를 가지는 arr1과 더하니 브로드캐스팅이 됩니다.						│
└───────────────────────────────────────────────────────────────────────┘

파이썬 리스트와 배열의 차이점
넘파이로 만든 배열과 04장에서 배운 CSV형 리스트는 생김새가 비슷하지만 같은 자료형은 아닙니다. 둘의 차이점을 간단치 알아보겠습니다.
┌───────────────────────────────────────────────────────────────────────────┐
│	>>> d = np.array([[1, 2, 3, 4, 5], [2, 4, 5, 6, 7], [5, 7, 8, 9, 9]])	│
│	# 3X5 배열 d를 정의합니다.                                                  	│
│	>>> d_list = [	[1, 2, 3, 4, 5],                                        │
│					[2, 4, 5, 6, 7],                                        │
│					[5, 7, 8, 9, 9]]                                        │
│	# 배열 d와 똑같이 생긴 CSV형 리스트를 만들어 d_list 객체에 저장합니다.                	│
│	>>> d_list                                                              │
│	[[1, 2, 3, 4, 5], [2, 4, 5, 6, 7], [5, 7, 8, 9, 9]]                     │
│	# array가 붙어 있지 않다는 점을 뺴면 d와 거의 같습니다.                            	│
│	>>> type(d_list)                                                        │
│	<class 'list'>                                                          │
│	# CSV형 객체의 자료형은 리스트입니다.                                           	│
│	>>> d_list[:2] = 0                                                      │
│	예외가 발생했습니다. TypeError                                               	│
│		can only assign an iterable                                         │
│		File PATH, line 138, in <module>                                    │
│		d_list[:2] = 0                                                      │
│	# d_list의 두 번째 원소까지 슬라이싱 해 0을 저장하라고 명령하면 오류가 발생합니다.			│
│	>>> d[:2] = 0                                                           │
│	# 배열 d의 두 번째 원소까지 슬라이싱 해 0을 저장하라고 명령합니다.						│
│	>>> d                                                                   │
│	array[	[0 0 0 0 0],                                                    │
│			[0 0 0 0 0],                                                    │
│			[5 7 8 9 9]]                                                    │
│	# 두 번째 리스트까지 모든 원소에 0을 저장합니다.                                   	│
└───────────────────────────────────────────────────────────────────────────┘

이러한 기능은 대량의 데이터를 한꺼번에 처리할 때 리스트보다 배열이 경쟁력 있음을 보여 줍니다.

인덱싱과 슬라이싱 연습하기
배열을 활용할 때 인덱싱과 슬라이싱을 자유자재로 할 수 있으면 자료를 마음껏 활용할 수 있습니다. 먼저 0부터 9까지 원소를 가지는 배열을 만들어 봅니다.
┌───────────────────────────────────────────┐
│	>>> arr4 = np.arange(10)				│
│	>>> arr4								│
│	# array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])	│
└───────────────────────────────────────────┘

배열에서 슬라이싱을 하는 방법은 기본적으로 리스트에서 슬라이싱을 하는 방식과 유사합니다. 예를 들어 arr4[:5]라고 하면 arr4[0]부터 arr4[4]까지 총 다섯 개 원소를 슬라이싱합니다.
┌───────────────────────────────────────────────────────────────┐
│	>>> arr4[:5]												│
│	array([0, 1, 2, 3, 4])	# 0부터 4까지 5개의 원소를 슬라이싱합니다.	│
└───────────────────────────────────────────────────────────────┘

arr[-3:]을 입력하면 뒤에서 세 번째 원소부터 마지막 원소까지 슬라이싱을 합니다.
┌───────────────────────┐
│	>>> arr4[-3:]		│	
│	array([7, 8, 9])	│
└───────────────────────┘

리스트가 여러 개 있으면 어떻게 할까요? 앞에서 만든 arr1 뱌열을 사용해 보겠습니다.
┌───────────────────────────────────────────────┐
│	>>> arr1                                    │
│	# array([[2, 3, 4], [6, 7, 8]])             │
│	>>> arr1[1,2]                               │
│	# 8											│
│	# arr1에서 두 번째 리스트의 세 번째 원소를 선택합니다.	│
│	>>> arr1[:, 2]								│
│	# array([4, 8])                             │
│	# 모든 리스트의 세 번째 원소를 슬라이싱 합니다.        	│
└───────────────────────────────────────────────┘

Do it 설문지 데이터 전처리하기 == 05-2.py 참조
지금까지 배운 넘파이 사용 방법을 연습하기 위해 CSV 파일에 저장된 데이터를 전처리하는 간단한 실습을 진행하겠습니다. 실습을 위해 5점 만점으로 된 설문 조사 결과가 quest.csv라는 파일에 저장되어 있다고 가정하겠습니다.
% 데이터 전처리(data preprocessting)란 데이터를 분석하기 좋게 미리 가공하는 일을 말합니다.

설문 조사의 각 항목을 1점부터 5점까지 입니다. 그런데 살펴보면 6이라는 숫자가 보이는군요. 이 자료를 파이썬으로 불러온 다음 잘못 입력된 점수를 수정해 보겠습니다.
┌───────────────────────────────────────────────────────────────────────────────────────────┐
│	import os, sys                                                                        	│
│	sys.path.append(os.path.dirname(os.path.abspath(os.path.dirname(__file__))))		    │
│	from Function import usercsv, Learning                                                  │
│	import numpy as np                                                                      │
│	                                                                                        │
│	fileName = 'quest.csv'                                                                  │
│	Learning.MoveLearningDataDir()                  # quest.csv를 저장한 경로로 이동             	│
│	quest = np.array(usercsv.switch(usercsv.opencsv(fileName, 0)))                          │
│	# quest.csv 파일을 열어 숫자 원소를 실수형으로 바꾼 다음 배열 형태로 quest 객체에 저장합니다.              	│
│	quest                                                                                   │
│	# array([[1., 2., 1., 2., 2.],                  # quest.csv 파일의 값이 배열로 잘 저장되었네요.  	│
│	#       [1., 3., 2., 3., 2.],                                                           │
│	#       [1., 4., 3., 3., 3.],                                                           │
│	#       [2., 5., 4., 4., 4.],                                                           │
│	#       [2., 5., 6., 2., 5.],                                                           │
│	#       [3., 6., 4., 2., 5.],                                                           │
│	#       [3., 5., 4., 1., 6.],                                                           │
│	#       [3., 5., 5., 1., 3.]])                                                          │
│	quest > 5                                       # 간단한 조건문을 입력해 볼까요?               	│
│	# array([[False, False, False, False, False],   # 5보다 큰면 True, 작거나 같으면 False입니다.	│
│	#        [False, False, False, False, False],											│
│	#        [False, False, False, False, False],                                           │
│	#        [False, False, False, False, False],                                           │
│	#        [False, False,  True, False, False],                                           │
│	#        [False,  True, False, False, False],                                           │
│	#        [False, False, False, False,  True],                                           │
│	#        [False, False, False, False, False]])                                          │
│	quest[quest > 5]                                # 인덱싱을 활용해 5보다 큰 수만 가져옵니다.       	│
│	# array([6., 6., 6.])                                                                  	│
│	quest[quest > 5] = 5                            # 5보다 큰 숫자가 전부 5로 바꿉니다.           	│
│	quest                                                                                  	│
│	# array([[1., 2., 1., 2., 2.],                  # 5보다 큰 숫자가 전부 5로 바뀌었네요           	│
│	#        [1., 3., 2., 3., 2.],                                                         	│
│	#        [1., 4., 3., 3., 3.],                                                          │
│	#        [2., 5., 4., 4., 4.],                                                          │
│	#        [2., 5., 5., 2., 5.],                                                          │
│	#        [3., 5., 4., 2., 5.],                                                          │
│	#        [3., 5., 4., 1., 5.],                                                          │
│	#        [3., 5., 5., 1., 3.]])                                                         │
│	usercsv.writecsv('resultcsv.csv', list(quest))                                          │
│	# 결과물을 다시 'resultcsv.csv'라는 이름으로 저장                                               	│
└───────────────────────────────────────────────────────────────────────────────────────────┘

저장 경로로 가서 resultcsv.csv 파일을 열면 다음과 같이 5보다 큰 수가 모두 5로 바뀌어 저장되었음을 확인해 볼 수 있습니다.
┌───────────────────────────────────┐
│	array([[1., 2., 1., 2., 2.],  	│
│	       [1., 3., 2., 3., 2.],  	│
│	       [1., 4., 3., 3., 3.],	│
│	       [2., 5., 4., 4., 4.],	│
│	       [2., 5., 5., 2., 5.],	│
│	       [3., 5., 4., 2., 5.],	│
│	       [3., 5., 4., 1., 5.],	│
│	       [3., 5., 5., 1., 3.]])	│
└───────────────────────────────────┘

05-3 넘파이로 사업성 분석하기	== 05-3.py 참조
 
넘파이는 주로 어디에서 유용하게 사용할까요? 특히 숫자를 많이 다루는 전문 분야, 연구와 관련된 분야일수록 대규모 데이터를 다워야 할 일이 많기 때문에 넘파이를 유용하게 사용합니다. 이번에는 우리가 검토해야 할 사업이 있다고 가정하고, 그 사업의 사업성을 분석하며 넘파이를 제대로 사용하는 방법을 알아보겠습니다.

사업성 분석이란
사업성 분석이란 간단히 말해 이 사업을 했을 때 이익이나 손해가 어느 정도 나올지 따져보는 것입니다.

경제적 타당성의 개넘
경제적 타당성은 간단히 말해 이 사업이 우리에게 비용 대비 얼마나 많은 효욜을 가져다 줄 수 있는지를 나타내는 개념입니다. 이를 본석하는 핵심 지표는 순현재가치(NPV)와 내부수익률(IRR)입니다.
┌───────────────────────────────────────────────────────────────────────────────┐
│	- 순현재가치(Net Present Value, NPV): 할인된 현금 흐름의 값을 모두 더한 값을 말합니다.		│
│	- 내부수익률(Internaal Rate of Return, IRR): 순현재가치를 0으로 만드는 할인율을 말합니다.	│
└───────────────────────────────────────────────────────────────────────────────┘

개념이 쉽지 않죠? 걱정하지 마세요. 다음에 나오는 세부 지표의 값을 구하면 핵심 지표의 값은 넘파이에 내장된 함수로 쉽게 값을 구할 수 있습니다. 값을 구해야 할 세부 지표는 다음과 같습니다.
┌───────────────────────┬───────────────────────┬───────────────────────────────────────────────────────────────────────────────────────────────┐
│	이름					│	공식					│	설명																							│
├───────────────────────┼───────────────────────┼───────────────────────────────────────────────────────────────────────────────────────────────┤
│	비용(C)				│	∑C					│	사업을 만드는 데 들어가는 모든 비용입니다.																│
├───────────────────────┼───────────────────────┼───────────────────────────────────────────────────────────────────────────────────────────────┤
│	수입(B)				│	∑B					│	사업을 하면서 발생하는 이익입니다.																	│
├───────────────────────┼───────────────────────┼───────────────────────────────────────────────────────────────────────────────────────────────┤
│	현금 흐름(CF)			│	CF = B - C			│	수입에서 비용을 제외한 금액입니다.																	│
├───────────────────────┼───────────────────────┼───────────────────────────────────────────────────────────────────────────────────────────────┤
│	연차(n)				│	-					│	총 사업 기간입니다.																				│
├───────────────────────┼───────────────────────┼───────────────────────────────────────────────────────────────────────────────────────────────┤
│	할인율(r)				│	-					│	미래의 현금 흐름을 현재 기준으로 환산할 떄 적용하는 비율입니다. 여기에서는 사회적 할인율을 적용합니다.					│
├───────────────────────┼───────────────────────┼───────────────────────────────────────────────────────────────────────────────────────────────┤
│	현금 흐름의 현재 가치(PV)	│	PV = CFk/(1 + r)k	│	할인율을 적요한 k년차 현금 흐름의 현재 가치를 의미합니다.													│
│						│						│	(F 옆 k는 아래의 작인 k, r)옆 k는 제곱의 k)															│
├───────────────────────┼───────────────────────┼───────────────────────────────────────────────────────────────────────────────────────────────┤
│	순현재가치(NPV)		│	NPV = ∑(CFk/(1+r)k)	│	투자 안의 매년 현재 가치(PV)를 다 더한 값입니다. 이 값이 0보다 크면 해당 투자 안에 사업성이 있다고 해석할 수 있습니다.	│
│						│						│	(F 옆 k는 아래의 작인 k, r)옆 k는 제곱의 k)															│
└───────────────────────┴───────────────────────┴───────────────────────────────────────────────────────────────────────────────────────────────┘
% 사회적 할인율이란 공공사업을 분석할 때 사용하는 미래 가치의 할인율을 말하며 2020년 6월 기준 4.5%를 사용할 수 있습니다.

여기서 비용, 수입, 현금 흐름, 연차는 개념이 단순합니다. 그런데 '할인율'과 '자본의 현재 가치'는 처음 이 개념을 접한 사람에게는 어렵게 느껴지겠네요. 자본의 현재 가치를 가상으로 구해 보면서 이해해 보겠습니다.

Do it 자본의 현재 가치 구하기	== 05-3.py 참조
1. 언제나 사용할 모듈을 먼저 임포트 합니다. numpy 모듈을 np로 임포트 하겠습니다.
2. 할인율과 현금 흐름을 설정합니다. 현금 흐름은 100억 원(단위:억원), 할인율을 5%라고 가정하겠습니다. discount에는 할인율, cashflow에는 현금 흐름을 저장합니다.
3. 현재 가치(PV)를 구하는 공식(PV = CFk/(1 + r)k)을 다음과 같은 함수로 만들겠습니다. 연차를 입력하면 그 해당 연차의 혐금 흐름의 현재 가치를 게산할 수 있습니다.
4. 공식을 사용해 보겠습니다. 완공 후 1, 2년 차일 때 현재 가치는 다음과 같습니다.
5. 20년 동안 발생할 현재 가치를 모두 한 번에 구할 수도 있습니다.
┌───────────────────────────────────────────────────────┐
│	>>> import numpy as np  # 먼저 넘파이를 임포트합니다.		│
│														│
│	>>> discount = .05      # 할인율은 5%입니다.				│
│	>>> cashflow = 100      # 현금 흐름은 100(억 원)입니다.	│
│														│
│	>>> def presentvalue(n):							│
│	   return (cashflow / (1 + discount) ** n)			│
│	# 자본의 현재 가치를 구하는 공식을 함수로 만듭니다.				│
│														│
│	>>> print(presentvalue(1))							│
│	95.23809523809524									│
│	>>> print(presentvalue(2))							│
│	90.70294784580499									│
└───────────────────────────────────────────────────────┘

이처럼 할인율 개념을 파이썬으로 간단하게 확인해 보는 것도 재미있는 방법입니다. 이제 조금 과감하게 진도를 나가보겠습니다.

Do it 놀이공원 사업의 사업성 분석하기	== 05-4.py 참조
이제 더 구체적인 상황을 가정하고 넘파이를 활용해 실습해 보겠습니다.

