# 05-2 넘파이로 배열 다루기
print('# 05-2 넘파이로 배열 다루기')

import numpy as np

a = np.array([[2,3],[5,2]])
# np.array는 배열을 정의하는 명령입니다. 첫 번째 행부터 리스트로 입력합니다.
print(a)
# 배열이 정상적으로 입력되었습니다.

d = np.array([[1, 2, 3, 4, 5],[2, 4, 5, 6, 7],[5, 7, 8, 9, 9]])
# 3 x 5 배열을 만들어 d에 저장합니다.
print(d)
#array(  [1, 2, 3, 4, 5],
#        [2, 4, 5, 6, 7],
#        [5, 7, 8, 9, 9]) 

print(d[1][2])
# 5 # d[1][2]를 행렬식으로 표현하면 [d오른쪽아래에 작은크기로 23] 에 해당하는 수입니따
print(d[1, 2])
# 5 # 이처럼 표현할 수도 있습니다.
print(d[1:, 3:])
# array([6, 7], [9, 9]) # 1행 다음, 3열 다음 수만 슬라이싱 했습니다.

# 배열의 크기 알아내기: shape
print('배열의 크기 알아내기: shape')
d = np.array([2, 3, 4, 5, 6])               # 1x5 배열을 만듭니다.
print(d)                                    # array([2, 3, 4, 5, 6])
d.shape                                     # (5,)      # d는 한 개 리스트에 각 다섯 개의 원소를 가지고 있습니다.
e = np.array([[1, 2, 3, 4], [3, 4, 5, 6]])    # 2x4 배열을 만듭니다.
print(e)                                    # array([1, 2, 3, 4], [3, 4, 5, 6])
e.shape                                     # (2, 4)    # e는 두 개 리스트에 각 네 개의 원소를 가지고 있습니다.

# 배열의 원소 유형 확인하기: dtype
print('배열의 원소 유형 확인하기: dtyoe')
d.dtype         # 배열 d의 자료형을 확인합니다.
# dtype('int32')  # 정수로 이뤄졌다는 의미입니다.

# 배열 유형 바꾸기: astype()
print('배열 유형 바꾸기: astype()')
data = np.arange(1, 5)	# 1부터 4까지로 이루어진 배열을 생성합니다.
data.dtype
# dtype('int32')			# 유형을 확인하니 정수입니다.
data.astype('float64')
# array([1., 2., 3., 4.])	# data 배열의 원소를 모두 실수로 바꿨습니다.
data.astype('int32')
# array([1, 2, 3, 4])		# 다시 정수로 바꿀 수도 있습니다.

# 넘파이 함수 알아보기
print('넘파이 함수 알아보기')
# 0으로 이뤄진 배열 만들기: np.zeros()
print('0으로 이뤄진 배열 만들기: np.zeros()')
np.zeros((2, 10))	# 행이 2이고 열일 10이며 각 원소가 0인 배열을 만듭니다.
# array([[0., 0., 0., 0., 0., 0., 0., 0., 0., 0., ], [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., ]])

# 1로 이워진 배열 만들기: np.ones()
print('1로 이워진 배열 만들기: np.ones()')
np.ones((2, 10))	# 행이 2이고 열일 10이며 각 원소가 1인 배열을 만듭니다.
# array([[1., 1., 1., 1., 1., 1., 1., 1., 1., 1., ], [1., 1., 1., 1., 1., 1., 1., 1., 1., 1., ]])

# 연속형 정수 생성하기: np.arange()
print('연속형 정수 생성하기: np.arange()')
np.arange(2, 10)		# 2 이상 10 미만의 원소로 이뤄진 1차원 배열을 만듭니다.
# array([2, 3, 4, 5, 6, 7, 8, 9])

# 행과 열을 바꾸기: np.transpose()
print('# 행과 열을 바꾸기: np.transpose()')
a = np.ones((2, 3))			# 원소가 전부 1인 2x3 배열을 만듭니다.
print(a)
# array([[1., 1., 1.], [1., 1., 1.]	])
b = np.transpose(a)			# a에 저장된 배열의 행과 열을 바꿔 b에 저장합니다.
print(b)
# array([	[1., 1.], [1., 1.], [1., 1.]])

# 배열의 사칙 연산
print('# 배열의 사칙 연산')
arr1 = np.array([[2, 3, 4], [6, 7, 8]])
arr2 = np.array([[12, 23, 14], [36, 47, 58]])

# 배열의 덧셈
print('# 배열의 덧셈')
print(arr1 + arr2)
# array([	[14, 26, 18], [42, 54, 66])

# 배열의 곱셈
print('배열의 곱셈')
print(arr1 * arr2)
# array([	[24, 69, 56], [216, 329, 464])	# 행렬의 곱셈과 다릅니다.

# 배열의 나눗셈
print('# 배열의 나눗셈')
print(arr1 / arr2)
# array([	[0.16666667 0.13043478 0.28571429], [0.16666667 0.14893617 0.13793103])	# array[0][0] =2/16 = 0.16666667

# 크기가 서로 다른 배열끼리 더하기
print('# 크기가 서로 다른 배열끼리 더하기')
arr3 = np.array([100, 200, 300])

arr1.shape
# (2,3)
arr3.shape
# (3,)			# arr1과 arr3는 크기가 다릅니다.
arr1 + arr3
# array[	[102, 203, 304], [106, 207, 308]]

arr4 = np.array([1,2,3,4,5,6,7,8,9,10])
arr4.shape
# (10,)
arr1.shape
# (2,3)
try:
    arr1 + arr4
except:
    print('False arr1 + arr4')

arr5 = np.array([[9], [3]])
arr5.shape
# (2,1)
print(arr1)
# array([	[2, 3, 4], [6, 7, 8]])
print(arr1 + arr5)
# array([	[11, 12, 13], [9, 10, 11]])	# arr1[0,:](1행)에 arr5[0][0]인 9를 각각 더합니다.
# (2,3)크기를 가지는 arr1과 더하니 브로드캐스팅이 됩니다.

# 파이썬 리스트와 배열의 차이점
print('# 파이썬 리스트와 배열의 차이점')
d = np.array([[1, 2, 3, 4, 5], [2, 4, 5, 6, 7], [5, 7, 8, 9, 9]])
# 3X5 배열 d를 정의합니다.
d_list = [[1, 2, 3, 4, 5], 
[2, 4, 5, 6, 7], 
[5, 7, 8, 9, 9]]
# 배열 d와 똑같이 생긴 CSV형 리스트를 만들어 d_list 객체에 저장합니다.
print(d_list)
# [[1, 2, 3, 4, 5], [2, 4, 5, 6, 7], [5, 7, 8, 9, 9]]
# array가 붙어 있지 않다는 점을 뺴면 d와 거의 같습니다.
print(type(d_list))
# <class 'list'> # CSV형 객체의 자료형은 리스트입니다.
try:
    d_list[:2] = 0
except:
    print('d_list[:2] = 0 출력 결과\n예외가 발생했습니다. TypeError\n can only assign an iterable\n File PATH, line 139, in <module>\n d_list[:2] = 0')
# d_list의 두 번째 원소까지 슬라이싱 해 0을 저장하라고 명령하면 오류가 발생합니다.

d[:2] = 0
# 배열 d의 두 번째 원소까지 슬라이싱 해 0을 저장하라고 명령합니다.
print(d)
# array[[0 0 0 0 0], [0 0 0 0 0], [5 7 8 9 9]]
# 두 번째 리스트까지 모든 원소에 0을 저장합니다. 

# 인덱싱과 슬라이싱 연습하기
print('# 인덱싱과 슬라이싱 연습하기')
arr4 = np.arange(10)
print(arr4)
# array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
arr4[:5]
# array([0, 1, 2, 3, 4])	# 0부터 4까지 5개의 원소를 슬라이싱합니다.
arr4[-3:]
# array([7, 8, 9])

arr1
# array([[2, 3, 4], [6, 7, 8]])
arr1[1,2]
# 8
# arr1에서 두 번째 리스트의 세 번째 원소를 선택합니다.
arr1[:, 2]
# array([4, 8])
# 모든 리스트의 세 번째 원소를 슬라이싱 합니다.